% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dispersal.R
\name{spread3}
\alias{spread3}
\title{An alternative spread function -- conceived for insects}
\usage{
spread3(start, rasQuality, rasAbundance, advectionDir, advectionMag,
  meanDist, plot.it = 2, minNumAgents = 50,
  verbose = getOption("LandR.verbose", 0))
}
\arguments{
\item{start}{Raster indices from which to initiate dispersal}

\item{rasQuality}{A raster with habitat quality. Currently, must
be scaled from 0 to 1, i.e., a probability of "settling"}

\item{rasAbundance}{A raster where each pixel represents the number
of "agents" or pseudo-agents contained. This number of agents, will
be spread horizontally, and distributed from each pixel
that contains a non-zero non NA value.}

\item{advectionDir}{A single number or RasterLayer in degrees from North = 0, indicating
the direction of advective forcing (i.e., wind). Will soon allow a
raster of advection vectors.}

\item{advectionMag}{A single number in distance units of the
\code{rasQuality}, e.g., meters, indicating the relative forcing that will
occur. It is imposed on the total event, i.e., if the \code{meanDist} is
\code{10000}, and \code{advectionMag} is \code{5000}, then the expected
distance (i.e., 63% of agents) will have settled by \code{15000} map units.}

\item{meanDist}{A single number indicating the mean distance parameter in map units
(not pixels), for a negative exponential distribution
dispersal kernel (e.g., \code{dexp}). This will mean that 63% of agents will have
settled at this \code{meanDist} (still experimental)}

\item{plot.it}{Numeric. With increasing numbers above 0, there will be plots
produced during iterations. Currently, only 0, 1, or 2+ are discinct.}

\item{minNumAgents}{Single numeric indicating the minimum number of agents
to consider all dispersing finished. Default is 50}
}
\value{
A \code{data.table} with all information used during the spreading
}
\description{
This is built with \code{\link[SpaDES.tools]{spread2}} and
is still experimental. This one differs from other attempts
in that it treats the advection and dispersal as mathematical
vectors that are added together. They are "rounded" to pixel
centres.
}
\examples{

#########################################################
# Simple case, no variation in rasQuality, numeric advectionDir and advectionMag
#########################################################
library(raster)
library(quickPlot)
maxDim <- 10000
ras <- raster::raster(extent(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
rasQuality <- raster(ras)
rasQuality[] <- 1
rasAbundance <- raster(rasQuality)
rasAbundance[] <- 0
# startPixel <- middlePixel(rasAbundance)
startPixel <- sample(seq(ncell(rasAbundance)), 30)
rasAbundance[startPixel] <- 1000
advectionDir <- 70
advectionMag <- 4 * res(rasAbundance)[1]
meanDist <- 2600

dev() # don't use Rstudio windows, which is very slow
clearPlot()
out <- spread3(rasAbundance = rasAbundance,
        rasQuality = rasQuality,
        advectionDir = advectionDir,
        advectionMag = advectionMag,
        meanDist = meanDist, verbose = 2,
        plot.it = 2)

# Test the dispersal kernel
out[, disGroup:=round(distance/100)*100]
freqs <- out[, .N, by = "disGroup"]
freqs[, cumSum := cumsum(N) ]
#plot(freqs$disGroup, freqs$cumSum) # can plot the distance X number
#abline(v = advectionMag + meanDist)
# should be 0.63:
freqs[disGroup == advectionMag + meanDist, cumSum]/
   tail(freqs,1)[, cumSum]

#########################################################
### The case of variable quality raster
#########################################################
library(sf) # needed to use fasterize
library(SpaDES.tools) # for gaussMap
library(fasterize) # faster than raster::rasterize
a <- randomStudyArea(size = 1e9)
ras <- raster(extent(a), res = 100)
mask <- fasterize(st_as_sf(a), ras)
rasQuality <- gaussMap(ras)
crs(rasQuality) <- crs(a)
rasQuality[is.na(mask)] <- NA
# rescale so min is 0.75 and max is 1
rasQuality[] <- rasQuality[] / (maxValue(rasQuality) * 4 ) + 3/4
rasAbundance <- raster(rasQuality)
rasAbundance[] <- 0
startPixel <- sample(seq(ncell(rasAbundance)), 300)
rasAbundance[startPixel] <- 1000
advectionDir <- 90
advectionMag <- 4 * res(rasAbundance)[1]
clearPlot()
out <- spread3(rasAbundance = rasAbundance,
        rasQuality = rasQuality,
        advectionDir = advectionDir,
        advectionMag = advectionMag,
        meanDist = 600, verbose = 2,
        plot.it = 1)

#########################################################
### The case of variable quality raster, raster for advectionDir
#########################################################
library(raster)
library(quickPlot)
library(SpaDES.tools)
maxDim <- 10000
ras <- raster::raster(extent(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
rasQuality <- raster(ras)
rasQuality[] <- 1
rasAbundance <- raster(rasQuality)
rasAbundance[] <- 0
# startPixel <- middlePixel(rasAbundance)
startPixel <- sample(seq(ncell(rasAbundance)), 2)
rasAbundance[startPixel] <- 1000
advectionDir <- gaussMap(ras)
crs(advectionDir) <- crs(rasQuality)
# rescale so min is 0.75 and max is 1
advectionDir[] <- advectionDir[] / (maxValue(advectionDir)) * 360
advectionMag <- 4 * res(rasAbundance)[1]
dev() # don't use Rstudio windows, which is very slow
clearPlot()
out <- spread3(rasAbundance = rasAbundance,
        rasQuality = rasQuality,
        advectionDir = advectionDir,
        advectionMag = advectionMag,
        meanDist = 600, verbose = 2,
        plot.it = 1)
}
